/*
  This file was generated automatically with scripts/maple2c.py.
  Do not edit this file directly as it can be overwritten!!

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Maple version     : Maple 2024 (X86 64 LINUX)
  Maple source      : ./maple/lda_exc/lda_c_rpa.mpl
  Type of functional: lda_exc
*/

#define maple2c_order 4
#define MAPLE2C_FLAGS (XC_FLAGS_I_HAVE_EXC | XC_FLAGS_I_HAVE_VXC | XC_FLAGS_I_HAVE_FXC | XC_FLAGS_I_HAVE_KXC | XC_FLAGS_I_HAVE_LXC)


#ifndef XC_DONT_COMPILE_EXC
GPU_DEVICE_FUNCTION static inline void
func_exc_unpol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t9, t12;
  double t13, t15, t18, tzk0;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = POW_1_3(rho[0]);
  t9 = t6 / t7;
  t12 = log(t4 * t9 / 0.4e1);
  t13 = 0.311e-1 * t12;
  t15 = 0.18e-1 * t12 - 0.36e-1;
  t18 = t4 * t9 * t15 / 0.8e1;
  tzk0 = t13 - 0.48e-1 + t18;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

}

#endif


#ifndef XC_DONT_COMPILE_VXC
GPU_DEVICE_FUNCTION static inline void
func_vxc_unpol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t9, t12;
  double t13, t15, t18, tzk0;

  double t19, t23, t25, t27, tvrho0;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = POW_1_3(rho[0]);
  t9 = t6 / t7;
  t12 = log(t4 * t9 / 0.4e1);
  t13 = 0.311e-1 * t12;
  t15 = 0.18e-1 * t12 - 0.36e-1;
  t18 = t4 * t9 * t15 / 0.8e1;
  tzk0 = t13 - 0.48e-1 + t18;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t19 = 0.1e1 / rho[0];
  t23 = t6 / t7 / rho[0];
  t25 = t4 * t23 * t15;
  t27 = t4 * t23;
  tvrho0 = t13 - 0.48e-1 + t18 + rho[0] * (-0.10366666666666666667e-1 * t19 - t25 / 0.24e2 - 0.75e-3 * t27);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

}

#endif


#ifndef XC_DONT_COMPILE_FXC
GPU_DEVICE_FUNCTION static inline void
func_fxc_unpol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t9, t12;
  double t13, t15, t18, tzk0;

  double t19, t23, t25, t27, tvrho0;

  double t34, t35, t39, t41, t43, tv2rho20;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = POW_1_3(rho[0]);
  t9 = t6 / t7;
  t12 = log(t4 * t9 / 0.4e1);
  t13 = 0.311e-1 * t12;
  t15 = 0.18e-1 * t12 - 0.36e-1;
  t18 = t4 * t9 * t15 / 0.8e1;
  tzk0 = t13 - 0.48e-1 + t18;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t19 = 0.1e1 / rho[0];
  t23 = t6 / t7 / rho[0];
  t25 = t4 * t23 * t15;
  t27 = t4 * t23;
  tvrho0 = t13 - 0.48e-1 + t18 + rho[0] * (-0.10366666666666666667e-1 * t19 - t25 / 0.24e2 - 0.75e-3 * t27);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

  t34 = rho[0] * rho[0];
  t35 = 0.1e1 / t34;
  t39 = t6 / t7 / t34;
  t41 = t4 * t39 * t15;
  t43 = t4 * t39;
  tv2rho20 = -0.20733333333333333334e-1 * t19 - t25 / 0.12e2 - 0.15e-2 * t27 + rho[0] * (0.10366666666666666667e-1 * t35 + t41 / 0.18e2 + 0.125e-2 * t43);

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 0] += tv2rho20;

}

#endif


#ifndef XC_DONT_COMPILE_KXC
GPU_DEVICE_FUNCTION static inline void
func_kxc_unpol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t9, t12;
  double t13, t15, t18, tzk0;

  double t19, t23, t25, t27, tvrho0;

  double t34, t35, t39, t41, t43, tv2rho20;

  double t50, t51, t55, t57, t59, tv3rho30;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = POW_1_3(rho[0]);
  t9 = t6 / t7;
  t12 = log(t4 * t9 / 0.4e1);
  t13 = 0.311e-1 * t12;
  t15 = 0.18e-1 * t12 - 0.36e-1;
  t18 = t4 * t9 * t15 / 0.8e1;
  tzk0 = t13 - 0.48e-1 + t18;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t19 = 0.1e1 / rho[0];
  t23 = t6 / t7 / rho[0];
  t25 = t4 * t23 * t15;
  t27 = t4 * t23;
  tvrho0 = t13 - 0.48e-1 + t18 + rho[0] * (-0.10366666666666666667e-1 * t19 - t25 / 0.24e2 - 0.75e-3 * t27);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

  t34 = rho[0] * rho[0];
  t35 = 0.1e1 / t34;
  t39 = t6 / t7 / t34;
  t41 = t4 * t39 * t15;
  t43 = t4 * t39;
  tv2rho20 = -0.20733333333333333334e-1 * t19 - t25 / 0.12e2 - 0.15e-2 * t27 + rho[0] * (0.10366666666666666667e-1 * t35 + t41 / 0.18e2 + 0.125e-2 * t43);

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 0] += tv2rho20;

  t50 = t34 * rho[0];
  t51 = 0.1e1 / t50;
  t55 = t6 / t7 / t50;
  t57 = t4 * t55 * t15;
  t59 = t4 * t55;
  tv3rho30 = 0.31100000000000000001e-1 * t35 + t41 / 0.6e1 + 0.375e-2 * t43 + rho[0] * (-0.20733333333333333334e-1 * t51 - 0.7e1 / 0.54e2 * t57 - 0.325e-2 * t59);

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 0] += tv3rho30;

}

#endif


#ifndef XC_DONT_COMPILE_LXC
GPU_DEVICE_FUNCTION static inline void
func_lxc_unpol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t9, t12;
  double t13, t15, t18, tzk0;

  double t19, t23, t25, t27, tvrho0;

  double t34, t35, t39, t41, t43, tv2rho20;

  double t50, t51, t55, t57, t59, tv3rho30;

  double t66, t71, tv4rho40;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = POW_1_3(rho[0]);
  t9 = t6 / t7;
  t12 = log(t4 * t9 / 0.4e1);
  t13 = 0.311e-1 * t12;
  t15 = 0.18e-1 * t12 - 0.36e-1;
  t18 = t4 * t9 * t15 / 0.8e1;
  tzk0 = t13 - 0.48e-1 + t18;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t19 = 0.1e1 / rho[0];
  t23 = t6 / t7 / rho[0];
  t25 = t4 * t23 * t15;
  t27 = t4 * t23;
  tvrho0 = t13 - 0.48e-1 + t18 + rho[0] * (-0.10366666666666666667e-1 * t19 - t25 / 0.24e2 - 0.75e-3 * t27);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

  t34 = rho[0] * rho[0];
  t35 = 0.1e1 / t34;
  t39 = t6 / t7 / t34;
  t41 = t4 * t39 * t15;
  t43 = t4 * t39;
  tv2rho20 = -0.20733333333333333334e-1 * t19 - t25 / 0.12e2 - 0.15e-2 * t27 + rho[0] * (0.10366666666666666667e-1 * t35 + t41 / 0.18e2 + 0.125e-2 * t43);

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 0] += tv2rho20;

  t50 = t34 * rho[0];
  t51 = 0.1e1 / t50;
  t55 = t6 / t7 / t50;
  t57 = t4 * t55 * t15;
  t59 = t4 * t55;
  tv3rho30 = 0.31100000000000000001e-1 * t35 + t41 / 0.6e1 + 0.375e-2 * t43 + rho[0] * (-0.20733333333333333334e-1 * t51 - 0.7e1 / 0.54e2 * t57 - 0.325e-2 * t59);

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 0] += tv3rho30;

  t66 = t34 * t34;
  t71 = t6 / t7 / t66;
  tv4rho40 = -0.82933333333333333336e-1 * t51 - 0.14e2 / 0.27e2 * t57 - 0.13e-1 * t59 + rho[0] * (0.62200000000000000002e-1 / t66 + 0.35e2 / 0.81e2 * t4 * t71 * t15 + 0.11611111111111111111e-1 * t4 * t71);

  if(out->v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    out->v4rho4[ip*p->dim.v4rho4 + 0] += tv4rho40;

}

#endif


#ifndef XC_DONT_COMPILE_EXC
GPU_DEVICE_FUNCTION static inline void
func_exc_pol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t8, t10;
  double t13, t14, t16, t19, tzk0;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = rho[0] + rho[1];
  t8 = POW_1_3(t7);
  t10 = t6 / t8;
  t13 = log(t4 * t10 / 0.4e1);
  t14 = 0.311e-1 * t13;
  t16 = 0.18e-1 * t13 - 0.36e-1;
  t19 = t4 * t10 * t16 / 0.8e1;
  tzk0 = t14 - 0.48e-1 + t19;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

}

#endif


#ifndef XC_DONT_COMPILE_VXC
GPU_DEVICE_FUNCTION static inline void
func_vxc_pol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t8, t10;
  double t13, t14, t16, t19, tzk0;

  double t20, t24, t26, t28, tvrho0, tvrho1;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = rho[0] + rho[1];
  t8 = POW_1_3(t7);
  t10 = t6 / t8;
  t13 = log(t4 * t10 / 0.4e1);
  t14 = 0.311e-1 * t13;
  t16 = 0.18e-1 * t13 - 0.36e-1;
  t19 = t4 * t10 * t16 / 0.8e1;
  tzk0 = t14 - 0.48e-1 + t19;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t20 = 0.1e1 / t7;
  t24 = t6 / t8 / t7;
  t26 = t4 * t24 * t16;
  t28 = t4 * t24;
  tvrho0 = t14 - 0.48e-1 + t19 + t7 * (-0.10366666666666666667e-1 * t20 - t26 / 0.24e2 - 0.75e-3 * t28);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

  tvrho1 = tvrho0;

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 1] += tvrho1;

}

#endif


#ifndef XC_DONT_COMPILE_FXC
GPU_DEVICE_FUNCTION static inline void
func_fxc_pol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t8, t10;
  double t13, t14, t16, t19, tzk0;

  double t20, t24, t26, t28, tvrho0, tvrho1;

  double t35, t36, t40, t42, t44, tv2rho20, tv2rho21, tv2rho22;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = rho[0] + rho[1];
  t8 = POW_1_3(t7);
  t10 = t6 / t8;
  t13 = log(t4 * t10 / 0.4e1);
  t14 = 0.311e-1 * t13;
  t16 = 0.18e-1 * t13 - 0.36e-1;
  t19 = t4 * t10 * t16 / 0.8e1;
  tzk0 = t14 - 0.48e-1 + t19;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t20 = 0.1e1 / t7;
  t24 = t6 / t8 / t7;
  t26 = t4 * t24 * t16;
  t28 = t4 * t24;
  tvrho0 = t14 - 0.48e-1 + t19 + t7 * (-0.10366666666666666667e-1 * t20 - t26 / 0.24e2 - 0.75e-3 * t28);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

  tvrho1 = tvrho0;

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 1] += tvrho1;

  t35 = t7 * t7;
  t36 = 0.1e1 / t35;
  t40 = t6 / t8 / t35;
  t42 = t4 * t40 * t16;
  t44 = t4 * t40;
  tv2rho20 = -0.20733333333333333334e-1 * t20 - t26 / 0.12e2 - 0.15e-2 * t28 + t7 * (0.10366666666666666667e-1 * t36 + t42 / 0.18e2 + 0.125e-2 * t44);

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 0] += tv2rho20;

  tv2rho21 = tv2rho20;

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 1] += tv2rho21;

  tv2rho22 = tv2rho21;

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 2] += tv2rho22;

}

#endif


#ifndef XC_DONT_COMPILE_KXC
GPU_DEVICE_FUNCTION static inline void
func_kxc_pol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t8, t10;
  double t13, t14, t16, t19, tzk0;

  double t20, t24, t26, t28, tvrho0, tvrho1;

  double t35, t36, t40, t42, t44, tv2rho20, tv2rho21, tv2rho22;

  double t51, t52, t56, t58, t60, tv3rho30, tv3rho31, tv3rho32;
  double tv3rho33;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = rho[0] + rho[1];
  t8 = POW_1_3(t7);
  t10 = t6 / t8;
  t13 = log(t4 * t10 / 0.4e1);
  t14 = 0.311e-1 * t13;
  t16 = 0.18e-1 * t13 - 0.36e-1;
  t19 = t4 * t10 * t16 / 0.8e1;
  tzk0 = t14 - 0.48e-1 + t19;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t20 = 0.1e1 / t7;
  t24 = t6 / t8 / t7;
  t26 = t4 * t24 * t16;
  t28 = t4 * t24;
  tvrho0 = t14 - 0.48e-1 + t19 + t7 * (-0.10366666666666666667e-1 * t20 - t26 / 0.24e2 - 0.75e-3 * t28);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

  tvrho1 = tvrho0;

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 1] += tvrho1;

  t35 = t7 * t7;
  t36 = 0.1e1 / t35;
  t40 = t6 / t8 / t35;
  t42 = t4 * t40 * t16;
  t44 = t4 * t40;
  tv2rho20 = -0.20733333333333333334e-1 * t20 - t26 / 0.12e2 - 0.15e-2 * t28 + t7 * (0.10366666666666666667e-1 * t36 + t42 / 0.18e2 + 0.125e-2 * t44);

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 0] += tv2rho20;

  tv2rho21 = tv2rho20;

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 1] += tv2rho21;

  tv2rho22 = tv2rho21;

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 2] += tv2rho22;

  t51 = t35 * t7;
  t52 = 0.1e1 / t51;
  t56 = t6 / t8 / t51;
  t58 = t4 * t56 * t16;
  t60 = t4 * t56;
  tv3rho30 = 0.31100000000000000001e-1 * t36 + t42 / 0.6e1 + 0.375e-2 * t44 + t7 * (-0.20733333333333333334e-1 * t52 - 0.7e1 / 0.54e2 * t58 - 0.325e-2 * t60);

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 0] += tv3rho30;

  tv3rho31 = tv3rho30;

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 1] += tv3rho31;

  tv3rho32 = tv3rho31;

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 2] += tv3rho32;

  tv3rho33 = tv3rho32;

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 3] += tv3rho33;

}

#endif


#ifndef XC_DONT_COMPILE_LXC
GPU_DEVICE_FUNCTION static inline void
func_lxc_pol(const xc_func_type *p, size_t ip, const double *rho, xc_lda_out_params *out)
{
  double t1, t3, t4, t5, t6, t7, t8, t10;
  double t13, t14, t16, t19, tzk0;

  double t20, t24, t26, t28, tvrho0, tvrho1;

  double t35, t36, t40, t42, t44, tv2rho20, tv2rho21, tv2rho22;

  double t51, t52, t56, t58, t60, tv3rho30, tv3rho31, tv3rho32;
  double tv3rho33;

  double t67, t72, tv4rho40, tv4rho41, tv4rho42, tv4rho43, tv4rho44;


  t1 = M_CBRT3;
  t3 = POW_1_3(0.1e1 / M_PI);
  t4 = t1 * t3;
  t5 = M_CBRT4;
  t6 = t5 * t5;
  t7 = rho[0] + rho[1];
  t8 = POW_1_3(t7);
  t10 = t6 / t8;
  t13 = log(t4 * t10 / 0.4e1);
  t14 = 0.311e-1 * t13;
  t16 = 0.18e-1 * t13 - 0.36e-1;
  t19 = t4 * t10 * t16 / 0.8e1;
  tzk0 = t14 - 0.48e-1 + t19;

  if(out->zk != NULL && (p->info->flags & XC_FLAGS_HAVE_EXC))
    out->zk[ip*p->dim.zk + 0] += tzk0;

  t20 = 0.1e1 / t7;
  t24 = t6 / t8 / t7;
  t26 = t4 * t24 * t16;
  t28 = t4 * t24;
  tvrho0 = t14 - 0.48e-1 + t19 + t7 * (-0.10366666666666666667e-1 * t20 - t26 / 0.24e2 - 0.75e-3 * t28);

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 0] += tvrho0;

  tvrho1 = tvrho0;

  if(out->vrho != NULL && (p->info->flags & XC_FLAGS_HAVE_VXC))
    out->vrho[ip*p->dim.vrho + 1] += tvrho1;

  t35 = t7 * t7;
  t36 = 0.1e1 / t35;
  t40 = t6 / t8 / t35;
  t42 = t4 * t40 * t16;
  t44 = t4 * t40;
  tv2rho20 = -0.20733333333333333334e-1 * t20 - t26 / 0.12e2 - 0.15e-2 * t28 + t7 * (0.10366666666666666667e-1 * t36 + t42 / 0.18e2 + 0.125e-2 * t44);

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 0] += tv2rho20;

  tv2rho21 = tv2rho20;

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 1] += tv2rho21;

  tv2rho22 = tv2rho21;

  if(out->v2rho2 != NULL && (p->info->flags & XC_FLAGS_HAVE_FXC))
    out->v2rho2[ip*p->dim.v2rho2 + 2] += tv2rho22;

  t51 = t35 * t7;
  t52 = 0.1e1 / t51;
  t56 = t6 / t8 / t51;
  t58 = t4 * t56 * t16;
  t60 = t4 * t56;
  tv3rho30 = 0.31100000000000000001e-1 * t36 + t42 / 0.6e1 + 0.375e-2 * t44 + t7 * (-0.20733333333333333334e-1 * t52 - 0.7e1 / 0.54e2 * t58 - 0.325e-2 * t60);

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 0] += tv3rho30;

  tv3rho31 = tv3rho30;

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 1] += tv3rho31;

  tv3rho32 = tv3rho31;

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 2] += tv3rho32;

  tv3rho33 = tv3rho32;

  if(out->v3rho3 != NULL && (p->info->flags & XC_FLAGS_HAVE_KXC))
    out->v3rho3[ip*p->dim.v3rho3 + 3] += tv3rho33;

  t67 = t35 * t35;
  t72 = t6 / t8 / t67;
  tv4rho40 = -0.82933333333333333336e-1 * t52 - 0.14e2 / 0.27e2 * t58 - 0.13e-1 * t60 + t7 * (0.62200000000000000002e-1 / t67 + 0.35e2 / 0.81e2 * t4 * t72 * t16 + 0.11611111111111111111e-1 * t4 * t72);

  if(out->v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    out->v4rho4[ip*p->dim.v4rho4 + 0] += tv4rho40;

  tv4rho41 = tv4rho40;

  if(out->v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    out->v4rho4[ip*p->dim.v4rho4 + 1] += tv4rho41;

  tv4rho42 = tv4rho41;

  if(out->v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    out->v4rho4[ip*p->dim.v4rho4 + 2] += tv4rho42;

  tv4rho43 = tv4rho42;

  if(out->v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    out->v4rho4[ip*p->dim.v4rho4 + 3] += tv4rho43;

  tv4rho44 = tv4rho43;

  if(out->v4rho4 != NULL && (p->info->flags & XC_FLAGS_HAVE_LXC))
    out->v4rho4[ip*p->dim.v4rho4 + 4] += tv4rho44;

}

#endif

